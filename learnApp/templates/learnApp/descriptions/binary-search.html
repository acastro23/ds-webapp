<div class="container py-4" style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 1.05rem;">

    <!---------------------------------------------------------Introduction Start-------------------------------------------------------------------------------------------------------->
    <div class="card mb-4 shadow-sm">
        <div class="card-body">
            <h2 class="card-title text-center">Introduction</h2>
            <p class="text-indent">
                Binary Search is an efficient algorithm for finding an element in a sorted array. It works by repeatedly dividing the search interval in half, similar to how you might 
                narrow down a number in a guessing game by asking whether the number is higher or lower than your guess. By eliminating half of the remaining elements in each step, 
                Binary Search quickly "singles out" the target element, reducing the number of comparisons needed.
            </p>
            <p class="text-indent">
                Binary Search is a classic example of a divide-and-conquer algorithm. Divide-and-conquer algorithms solve problems by breaking them into smaller subproblems, solving 
                each subproblem independently, and combining the results. This approach makes binary search highly efficient, with a time complexity of O(log n), making it significantly 
                faster than linear search for large datasets.
            </p>
            <p class="text-indent">
                The algorithm is widely used in computer science and real-world applications. It is commonly employed in searching sorted datasets, such as databases, dictionaries, and 
                index structures. Beyond searching, binary search is also a fundamental tool in solving optimization problems, such as finding the square root of a number or determining 
                the smallest feasible solution in a range of values. Its simplicity, efficiency, and versatility make it a cornerstone of algorithm design.
            </p>
        </div>
    </div>
    <!---------------------------------------------------------Introduction End---------------------------------------------------------------------------------------------------------->

    <!---------------------------------------------------------Binary Search Start-------------------------------------------------------------------------------->
    <div class="card mb-4 shadow-sm">
        <div class="card-body">
            <h3 class="card-title text-center">Binary Search</h3>
            <p class="text-indent">
                Binary search is a systematic method for locating a target value within a sorted array by leveraging the array's order. Unlike linear search, which examines each element sequentially, 
                binary search strategically eliminates half of the remaining elements in each step. This is achieved by repeatedly dividing the array into two halves and focusing only on the half 
                where the target could exist.
            </p>
            <p class="text-indent">
                At the core of binary search is the concept of maintaining a search interval, defined by two pointers: <b>low</b> and <b>high</b>. These pointers represent the boundaries of the 
                current search range. The algorithm calculates the middle index, <b>mid</b>, and compares the element at this index with the target value. Depending on the result of the comparison, 
                the search interval is adjusted by moving either the <b>low</b> or <b>high</b> pointer, effectively discarding the half of the array that cannot contain the target.
            </p>
            <p class="text-indent">
                This process of halving the search space continues iteratively until one of two conditions is met: the target value is found, or the search interval becomes empty, indicating that 
                the target is not present in the array. The efficiency of binary search lies in its ability to reduce the problem size exponentially with each step, resulting in a logarithmic 
                time complexity of O(log n).
            </p>
            <p class="text-indent">
                Binary search can be implemented in two primary ways: <b>iteratively</b> and <b>recursively</b>. Both approaches follow the same fundamental logic of halving the search interval 
                at each step, but they differ in how the algorithm is structured and executed. The iterative implementation uses a loop to manage the search interval, while the recursive 
                implementation leverages function calls to achieve the same result. The following sections explore these two approaches in detail, highlighting their advantages, limitations, 
                and use cases.
            </p>
        </div>
    </div>
    <!---------------------------------------------------------Binary Search End---------------------------------------------------------------------------------->

    <!---------------------------------------------------------Iterative Start-------------------------------------------------------------------------------------------->
    <div class="card mb-4 shadow-sm">
        <div class="card-body">
            <h3 class="card-title text-center">Iterative Binary Search</h3>
            <p class="text-indent">
                The iterative implementation of binary search uses a loop to repeatedly narrow down the search interval until the target is found or the interval becomes empty. 
                By systematically updating the <b>low</b>, <b>high</b>, and <b>mid</b> pointers (introduced earlier), the algorithm eliminates half of the 
                remaining elements in each iteration. This approach is often preferred for its simplicity and efficiency, as it avoids the overhead of recursive function calls.
            </p>
            <p class="text-indent">
                One of the key advantages of the iterative approach is its <b>space efficiency</b>. Unlike the recursive implementation, which requires additional memory for the 
                call stack, the iterative version operates entirely within a single function, resulting in a space complexity of O(1). This makes it particularly suitable for 
                memory-constrained environments or scenarios where the input size is very large.
            </p>
            <p class="text-indent">
                The iterative process begins by initializing the <b>low</b> and <b>high</b> pointers to the first and last indices of the array, respectively. The algorithm then 
                enters a loop that continues as long as <b>low</b> is less than or equal to <b>high</b>. Within each iteration, the middle index, <b>mid</b>, is calculated, and 
                the element at this index is compared with the target value. Depending on the result of the comparison:
            </p>
            <ul class="ms-4">
                <li><b>If the middle element equals the target:</b> The search is complete, and the index of the middle element is returned.</li>
                <li><b>If the middle element is greater than the target:</b> The search interval is updated to the left half by setting <b>high = mid - 1</b>.</li>
                <li><b>If the middle element is less than the target:</b> The search interval is updated to the right half by setting <b>low = mid + 1</b>.</li>
            </ul>
            <p class="text-indent">
                The loop continues until the target is found or the <b>low</b> pointer exceeds the <b>high</b> pointer, indicating that the target is not present in the array. 
                At this point, the algorithm typically returns a special value (e.g., -1) to signal that the search was unsuccessful.
            </p>
            <p class="text-indent">
                While the iterative implementation is straightforward, it requires careful attention to detail, particularly when calculating the <b>mid</b> index. A common 
                pitfall is the potential for integer overflow when computing <b>mid = (low + high) / 2</b> in languages where integers have fixed sizes. To avoid this, a safer 
                formula such as <b>mid = low + (high - low) / 2</b> is often used. 
            </p>
            <p class="text-indent">
                The following pseudocode demonstrates the iterative implementation of binary search:
            </p>
            <!-- pseudocode -->
        </div>
    </div>
    <!---------------------------------------------------------Iterative End---------------------------------------------------------------------------------------------->

    <!---------------------------------------------------------Recursive Start-------------------------------------------------------------------------------------------->
    <div class="card mb-4 shadow-sm">
        <div class="card-body">
            <h3 class="card-title text-center">Recursive Binary Search</h3>
            <p class="text-indent">
                The recursive implementation of binary search leverages the divide-and-conquer paradigm by repeatedly calling itself with a reduced search interval. 
                This approach mirrors the logical structure of binary search, breaking the problem into smaller subproblems until the target is found or the search interval becomes empty.
            </p>
            <p class="text-indent">
                The search interval is defined by two pointers: <b>low</b> and <b>high</b>. These pointers, along with the middle index 
                <b>mid</b>, are passed as arguments to each recursive call. Depending on the comparison between the target value and the element at <b>mid</b>, the algorithm adjusts 
                the search interval by recursively searching either the left or right half of the array:
            </p>
            <ul class="ms-4">
                <li><b>If the middle element equals the target:</b> The search is complete, and the index of the middle element is returned.</li>
                <li><b>If the middle element is greater than the target:</b> The algorithm recursively searches the left half by calling itself with <b>high = mid - 1</b>.</li>
                <li><b>If the middle element is less than the target:</b> The algorithm recursively searches the right half by calling itself with <b>low = mid + 1</b>.</li>
            </ul>
            <p class="text-indent">
                The recursion continues until one of two conditions is met: the target value is found, or the <b>low</b> pointer exceeds the <b>high</b> pointer, indicating that the 
                target is not present in the array. In the latter case, the algorithm typically returns a special value (e.g., -1) to signal that the search was unsuccessful.
            </p>
            <p class="text-indent">
                While the recursive implementation is conceptually intuitive, it comes with additional memory overhead due to the recursive call stack. Each recursive call adds a 
                frame to the stack, resulting in a space complexity of O(log n). This is in contrast to the iterative implementation, which operates in-place with a space complexity 
                of O(1). For very large arrays, excessive recursion depth can lead to stack overflow errors, especially in languages with limited stack size.
            </p>
            <p class="text-indent">
                Despite these challenges, the recursive approach is often favored for its clarity and alignment with the divide-and-conquer paradigm. However, in scenarios where 
                memory efficiency is critical, the iterative implementation may be a more practical choice.
            </p>
            <p class="text-indent">
                The following pseudocode demonstrates the recursive implementation of binary search:
            </p>
            <!-- pseudocode -->
        </div>
    </div>
    <!---------------------------------------------------------Recursive End---------------------------------------------------------------------------------------------->

    <!---------------------------------------------------------Example Start------------------------------------------------------------------------------------------------------------>
    <!-- <div class="card mb-4 shadow-sm">
        <div class="card-body">
          <h3 class="card-title text-center">Example</h3>
          <p class="text-center small fst-italic text-dark"><u>Given this sorted array, find the target value (X) using binary search:</u></p>
          <div class="text-center">
            <img src="/static/learnApp/images/binary_search_example.png" alt="Binary Search Example" class="img-fluid border-black" style="max-width: 300px; height: auto;">
          </div>
          <h4 class="text-center mt-4">Step-by-Step of Binary Search</h4>
          <div class="table-responsive">
            <table class="table table-bordered text-center">
              <thead class="table-light">
                <tr>
                  <th>Step</th>
                  <th>Low</th>
                  <th>High</th>
                  <th>Mid</th>
                  <th>Array State</th>
                  <th>Explanation</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>1</td>
                  <td>0</td>
                  <td>8</td>
                  <td>4</td>
                  <td>[1, 3, 5, 6, <b>7</b>, 8, 9, 10, 12]</td>
                  <td>Compare 7 with the middle element (7). Target found at index 4.</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
    </div> -->
    <!---------------------------------------------------------Example End-------------------------------------------------------------------------------------------------------------->

    <!---------------------------------------------------------Time Complexity Start---------------------------------------------------------------------------------------------------->
    <div class="card mb-4 shadow-sm">
        <div class="card-body">
          <h2 class="card-title text-center">Runtime</h2>
          <table class="w-50 mx-auto" style="border-collapse: collapse; border: 2px solid black;">
            <thead>
              <tr>
                <th style="border: 2px solid black; padding: 8px; text-align: center;" class="fw-semibold">Case</th>
                <th style="border: 2px solid black; padding: 8px; text-align: center;" class="fw-semibold">Time Complexity</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="border: 2px solid black; padding: 8px; text-align: center;">Best</td>
                <td style="border: 2px solid black; padding: 8px; text-align: center;">O(1)</td>
              </tr>
              <tr>
                <td style="border: 2px solid black; padding: 8px; text-align: center;">Average</td>
                <td style="border: 2px solid black; padding: 8px; text-align: center;">O(log n)</td>
              </tr>
              <tr>
                <td style="border: 2px solid black; padding: 8px; text-align: center;">Worst</td>
                <td style="border: 2px solid black; padding: 8px; text-align: center;">O(log n)</td>
              </tr>
            </tbody>
          </table>
        </div>
    </div>

    <!---------------------------------------------------------Time Complexity End------------------------------------------------------------------------------------------------------>

    <div class="card mb-4 shadow-sm">
        <div class="card-body">
            <h3 class="card-title text-center">Analysis</h3>
            <p class="text-indent">
                Binary search is unique in its efficiency for searching sorted arrays. Its logarithmic time complexity, O(log n), makes it significantly faster than linear search, 
                especially for large datasets. The algorithm's performance is consistent regardless of the input, as it always divides the search interval in half at each step. 
                This halving process ensures that the number of comparisons required to find the target grows logarithmically with the size of the array. For example, in an array 
                of size 1,000,000, binary search requires at most 20 comparisons to locate the target, compared to up to 1,000,000 comparisons in linear search.
            </p>
            <p class="text-indent">
                The logarithmic time complexity arises because the search interval is reduced by half in each step. Mathematically, this can be expressed as solving the recurrence 
                relation T(n) = T(n/2) + O(1), where T(n) represents the time complexity for an array of size n. The solution to this recurrence is O(log n), which reflects the 
                number of times the array can be divided by 2 before the search interval becomes empty. This efficiency makes binary search particularly well-suited for large datasets 
                where linear search would be prohibitively slow.
            </p>
            <p class="text-indent">
                However, binary search has limitations. It requires the input array to be sorted, which may involve additional preprocessing time if the array is unsorted. Sorting 
                the array typically takes O(n log n) time using efficient algorithms like merge sort or quicksort. While this preprocessing cost can be justified if multiple searches 
                are performed on the same dataset, it may be a disadvantage in scenarios where only a single search is needed. Additionally, implementing binary search correctly 
                can be tricky due to potential off-by-one errors when calculating the middle index, especially in languages with fixed integer sizes where overflow can occur.
            </p>
            <p class="text-indent">
                Despite these challenges, binary search remains a cornerstone of algorithmic problem-solving due to its speed and reliability in searching sorted datasets. It is 
                widely used in applications such as database indexing, searching in dictionaries, and solving optimization problems where the solution space can be narrowed down 
                iteratively.
            </p>
            <p class="text-indent">
                In terms of space complexity, binary search is highly efficient. The iterative implementation operates in-place, requiring only a constant amount of extra memory 
                for variables like low, high, and mid. This results in a space complexity of O(1), making it ideal for memory-constrained environments. 
                In contrast, the recursive implementation incurs additional memory overhead due to the recursive call stack, resulting in a space complexity of O(log n). 
                While this difference is negligible for small datasets, it can become significant for very large arrays, especially in environments with limited stack size.
            </p>
        </div>
    </div>