
<!---------------------------------------------------------Introduction Start-------------------------------------------------------------------------------------------------------->
<style>
    .border-black {
        border: 3px solid black;
        padding: 5px;
    }
    .fixed-size {
        width: 100%; 
        height: 300px;
        object-fit: contain;
    }
    .image-caption {
        font-style: italic;
        margin-top: 8px;
        font-size: 14px;
        color: #333;
    }
</style>

<!-- AC01312025 -- This section is the actual overview of the algorithm -->
<p style="text-indent: 30px;">
    While by definition, heaps are are defined as a "disordered collection of objects", that is definitly not what this data
    structure is. Heaps are a clever, partially ordered data structure that are useful for task such as implementing <i>priority queues</i> The concepts of heaps arise
    in several important algorithms such as: <i>Prim's algorithm, Dijkstra's algorithm, Huffman encoding, etc.</i> So, while this section is focused on the heapsort algorithm,
    it's important to have a basic understanding of <i>heaps</i> data structure, and the basic operations related to heaps in order to truly undersatnd heap sort.
</p><br>

<!---------------------------------------------------------Introduction End----------------------------------------------------------------------------------------------------------->


<h3 style="text-align: center;">Heaps</h3>
<p style="text-indent: 30px;">
    Heaps are an array-based data structure that can be viewed as a complete binary tree, where every level is fully filled except possibly the last, 
    which is filled from left to right. In a heap, each parent node has children, and each node in the heap corresponds to
   an element of an array. Take a look at the figure below to see the relation between a heap and array:
</p>


<div class="container">
    <div class="row align-items-center">
        <!-- This for left pic (Heap) -->
        <div class="col-md-5 text-center">
            <img src="/static/learnApp/images/heap_complete_visual.png" alt="Heap Tree" class="img-fluid border-black">
            <p class="image-caption">Heap Representation</p>
        </div>
        
        <div class="col-md-2"></div>

        <!-- Ths for right pic (Array) -->
        <div class="col-md-5 text-center d-flex flex-column align-items-center">
            <img src="/static/learnApp/images/heap_complete_visual_array.png" alt="Heap Array" class="img-fluid border-black">
            <p class="image-caption">Array Representation</p>
        </div>
    </div>
</div>


<p>
    <i><b>Note:</b></i> When looking at a node on a heap, you can determine its array index by the following:
</p>


<div class="container text-center my-4">
    <img src="/static/learnApp/images/heap_array_computation.png" alt="Heap-Array computation image" class="img-fluid border-black">
    <p class="image-caption">This image is from the <i>Introduction to Algorithms by Thomas H_ Cormen</i> book.</p>
</div>


<p style="text-indent: 30px;">
    There are two main types of heaps:
</p>

<ul style="margin-left: 40px;">
    <li><b><u>Max Heap:</u></b> The key at each node is greater than or equal to its children, and the root node contains the max element.</li>
    <li><b><u>Min Heap:</u></b> The key at each node is smaller than or equal to its children, and the root node contains the min element.</li>
</ul>


<p style="text-indent: 30px;">
    There are also two main approaches to building a heap:
</p>

<ul style="margin-left: 40px;">
    <li><b><u>Top down approach:</u></b> Given an array, a heap can be constructed by inserting an element one at a time. At each insertion, perform  <i>Max-heapify</i> to maintain the max heap property.</li>
    <li><b><u>Bottom up approach:</u></b> Given an array, construct a heap in accordance to the initial array, then perfrom <i>max-heapify</i> starting from the end of the heap to maintain the max-heap.</li>
</ul>


<!-----------------------------------------------------------Exercise Start----------------------------------------------------------------------------------------------------------->
<h3 style="text-align: center;"> Exercises </h3>

<p style="text-align: center;">The following 3 images are exercises, and the objective is to indentify what is a heap, and what is not. Try it!</p>

<!-----------------------------------------------------------Exercise End------------------------------------------------------------------------------------------------------------->


<div class="container">
    <div class="row text-center">
        <div class="col-md-4">
            <img src="/static/learnApp/images/heap_example1.png" alt="Exercise 1" class="img-fluid border-black fixed-size">
            <p class="image-caption"><u>Exercise 1</u>: <strong>Not</strong> a heap, does not satisfy either heap property</p>
        </div>

        <div class="col-md-4">
            <img src="/static/learnApp/images/heap_example2.png" alt="Exercise 2" class="img-fluid border-black fixed-size">
            <p class="image-caption"><u>Exercise 2</u>: <em>Is</em> a heap</p>
        </div>

        <div class="col-md-4">
            <img src="/static/learnApp/images/heap_example3.png" alt="Exercise 3" class="img-fluid border-black fixed-size">
            <p class="image-caption"><u>Exercise 3</u>: <strong>Not</strong> a heap, only the very last node can be missing from a heap</p>
        </div>
    </div>
</div>


<!-----------------------------------------------------------------------Heapify Start-------------------------------------------------------------------------------------------->
<br><h3 style="text-align: center;"> Maintaing Heap property </h3>
<p style="text-indent: 30px;">
    When discussing the methods for building a heap, you might recall the term "Max-heapify" being thrown around, but what exactly is that? <i>Max-heapify</i> helps maintain a property 
    knwon as the max-heap property where for every node <i>i</i> other than the root, the value of a node is at most the value of its parent. Meaning the largest element is stored at the 
    root, and the subtrees rooted at a node contain values no larger than that contained at the node itself. When Max-heapify is called, it assumes that the left(l) and right(r) child nodes
    are max heaps and that the root(i) might be smaller, breaking the heap property. When this occurs, max-heapify lets the node value i, "sink" in the heap until the max heap property 
    is satisfied. This done through recursion, Max-heapfiy calls itself recursively on the affected subtree, and this is the most common way to implement this operation, and although
    iterative implementaions are possible, it will not be discussed here.
</p><br>
<!-----------------------------------------------------------------------Heapify Ends-------------------------------------------------------------------------------------------->


<!-----------------------------------------------------------------------Insertion Start-------------------------------------------------------------------------------------------->
<h3 style="text-align: center;">Heap operations: Insertion</h3>
<p style="text-indent: 30px;">
    There are two main operations done on heap besides <i>heapify</i>, and those are insertion and deletion. Insertion is the simpler operation of the two, and is mainly a two step 
    process. Given a heap, inserting a new element is done at the end of the heap as the last index. Once an element is inserted, perform "Max-heapify" to ensure the max-heap property 
    is still satisfied. Here's an illustration: 
</p>

<div class="container">
    <div class="row text-center">
        <div class="col-md-4">
            <img src="/static/learnApp/images/heapInsert_step1.png" alt="Heap Insert Step 1" class="img-fluid border-black fixed-size">
            <p class="image-caption">Step 1: Insert new node at the end of heap</p>
        </div>

        <div class="col-md-4">
            <img src="/static/learnApp/images/heapInsert_step2.png" alt="Heap Insert Step 2" class="img-fluid border-black fixed-size">
            <p class="image-caption">Step 2: Perform Max-heapify</p>
        </div>

        <div class="col-md-4">
            <img src="/static/learnApp/images/heapInsert_step3.png" alt="Heap Insert Step 3" class="img-fluid border-black fixed-size">
            <p class="image-caption">End result</p>
        </div>
    </div>
</div>


<p style="text-indent: 30px;">
    The illustration is broken down into 3 steps. In Step 1, insert the node into the heap, and any new node insertion must be done at the end of the heap in order to maintain structure.
    In step 2, we perform the max-heapify operation on the heap to restore heap property, since the insertion of node element 10, the root element is no longer the largest in the heap.
    After performing max-heapifu, the result is the image in step 3 where 10 is now the root element, and if a new node were to be inserted, that element would be placed as the left child 
    of node element 6.
</p><br>

<!-----------------------------------------------------------------------Insertion ends---------------------------------------------------------------------------------------------->


<!-----------------------------------------------------------------------Deletion Start-------------------------------------------------------------------------------------------->
<h3 style="text-align: center;">Heap operations: Deletion</h3>
<p style="text-indent: 30px;">
    Deletion is a bit more complicated, and its a key operation done in heap sort. Given a heap, exchange the root's key with the last key of the heap, and decrease the heap's size 
    by 1. Perform "Max-heapify" to ensure the max-heap property is still satisfied. Here's an illustration:
</p>

<div class="container">
    <div class="row text-center">
        <div class="col-md-4">
            <img src="/static/learnApp/images/heap_complete_visual.png" alt="Heap for deletion" class="img-fluid border-black fixed-size">
            <p style="text-align: center;"> Figure 1</p>
        </div>

        <div class="col-md-4">
            <img src="/static/learnApp/images/heapDelete_step1.png" alt="Heap deletion Step 2" class="img-fluid border-black fixed-size">
            <p style="text-align: center;"> Figure 2</p>
        </div>

        <div class="col-md-4">
            <img src="/static/learnApp/images/heapDelete_step2.png" alt="Heap deletion Step 3" class="img-fluid border-black fixed-size">
            <p style="text-align: center;"> Figure 3</p>
        </div>
    </div>
</div>


<p style="text-indent: 30px;">
    Figure 2.1 starts with a heap structuren, and to perform one delete operation, we must delete the last node 3. Figure 2.2 swaps nod 3, with the root node, 9, and the connection 
    to the node is removed, since each time a "deletion" happens, the heap size decreases by one. In figure 2.3, max-heapify is performed to ensure the the heap property is satified.
</p><br>
<!-----------------------------------------------------------------------Deletion ends---------------------------------------------------------------------------------------------->


<!----------------------------------------------------------------Heap Sort Start---------------------------------------------------------------------------------------------------->
<h3 style="text-align: center;">Heap Sort</h3>

<p style="text-indent: 30px;">
    Finally, we get to heap sort, and its taken a while because heap sort requires a good understanding of heap operations, and now lets begin. 
    <i>Heap Sort</i> is a comparison-based sorting algorithm that uses the heap data structure. It begins by building a max-heap from the input array, ensuring that the largest element is 
    at the root of the heap. The sorting process then repeatedly swaps the root element (the largest element) with the last element of the heap, essentially removing it from the heap
    and placing it in its correctly sorted position in the array. After each swap, the heap size is reduced by one, and the heapify operation is applied to the root to restore the 
    max-heap property. This process continues until the heap is reduced to a single element, resulting in a fully sorted array. The procedure basically follows the delete and max-heapify
    operations, and here's a nice visual of this sorting algorithm in action:
</p>


<div class="container text-center my-4">
    <img src="/static/learnApp/images/heap_sort_visual.png" alt="Heap sort visual" class="img-fluid border-black">
    <p class="image-caption">This image comes from the the <i>Introduction to Algorithms by Thomas H. Cormen</i> book on page 168:</p>
</div>

<p style="text-indent: 30px;">
    Breaking down the image, <i>(a)</i> presents a max heap with 16 as the root node. The first step is to swap 16 with the last node, i.e., 1, and then restore the heap property. 
    Figure <i>(b)</i> does the process where 16 is swapped, and the heap size decreases by one hence why 16 is not connected to the heap, and 1 was at the root, but since max-heapify 
    is performed, the heap property is restored where the new root element is 14. Proceeding to figure <i>(c)</i>, the root node is swapped with the last element, the heap size 
    decreases by one again, and max-heapify is performed leaving 10 as the new root element. This procedure follows for the rest of the figures, and it's once we get to the last node,
    since it would already be in its correct position in a sorted array. The final result is a fully sorted array presented in figure <i>(k)</i>. 
</p><br>
<!----------------------------------------------------------------Heap Sort End------------------------------------------------------------------------------------------------------>


<!-----------------------------------------------------------Time Complexity Start---------------------------------------------------------------------------------------------------->
<div class="text-center">
    <h3>Time Complexity:</h3>
    <ul style="list-style-position: inside; text-align: center; display: inline-block;">
        <li><strong>Best case:</strong> O(nlogn)</li>
        <li><strong>Worst case:</strong> O(nlogn)</li>
        <li><strong>Average case:</strong> O(nlogn)</li>
    </ul>
</div><br>
<!-----------------------------------------------------------Time Complexity End---------------------------------------------------------------------------------------------------->

<h3 style="text-align: center;">Analysis</h3>

<p style="text-indent: 30px;">
    Like merge sort, heapsort has a runtime of O(nlogn) and like insertion sort, heapsort sorts in place, meaning only a constant number of array elements are stored outside of the input array at any given time. 
    Taking the best attributes from merge sort and insertion sort, we get an efficient sorting algorithm. However, this sorting algorithm still gets outperformed in practice by a 
    well-implemented quick sort algorithm, but why exactly is the runtime of heapsort O(nlogn).
</p>

<p style="text-indent: 30px;">
    Heapsort gets its O(nlogn) runtime from building the initial heap and then performing max-heapify. Recall that building a max heap takes O(n) times, where n is the number of
    vertices. Once a max-heap is set up, max-heapify takes O(logn) time, and it makes n-1 calls. Putting the two together gives us the expected runtime. It is also worth noting, that 
    the insert and delete operations are O(logn) since the key comparisons made after the operations are done can not be more than twice the heap's height which is log n.
</p>

<p><b><u>Space Complexity</u></b>:
Heapsort is an in-place alogrithm, unlike merge sort. This means the heapsort algorithm requires no extra space and has a space complexity of O(1).
</p>