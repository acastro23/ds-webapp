<div class="container py-4" style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 1.05rem;">

    <!-- AC01312025 -- This section is the actual overview of the algorithm -->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">Introduction</h2>
        <p class="text-indent">
          Bubblesort is a popular, but inefficient, sorting algorithm. It works by repeatedly swapping adjacent elements that are out of order, similar to air bubbles 
          in the water, where the largest "bubbles" up to the surface, each element of the array move to the end in each iteration, Hence the name <i>bubble</i> sort.
        </p>
        <p class="text-indent">
          Bubble Sort follows a brute-force-like approach. As the name suggests, brute-force algorithms take a straightforward method to solve problems, often by checking all possibilities. 
          Bubble Sort follows this idea by repeatedly iterating through the array, comparing and swapping adjacent elements until the entire array is sorted. Follow the example below to see 
          an iteration: 
        </p>
      </div>
    </div>
  
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Example</h3>
        <p class="text-center small fst-italic text-dark"><u>Given this array, sort it using bubble sort</u></p>
        <div class="text-center">
          <img src="/static/learnApp/images/bubble_sort_array.png" alt="Bubble Sort array" class="img-fluid border-black" style="max-width: 300px; height: auto;">
        </div>
  
        <h4 class="text-center mt-4">Step-by-Step of Bubble Sort</h4>
        <div class="table-responsive">
          <table class="table table-bordered text-center">
            <thead class="table-light">
              <tr>
                <th>Iteration</th>
                <th>Array</th>
                <th>Swaps Performed</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>1st iteration</td>
                <td>[4, 3, 1, 8, 5, 2, 7, 6, <b>9</b>]</td>
                <td>Swap 9 & 1 → Swap 9 & 8 → Swap 9 & 5 → Swap 9 & 2 → Swap 9 & 7 → Swap 9 & 6</td>
              </tr>
              <tr>
                <td>2nd iteration</td>
                <td>[3, 1, 4, 5, 2, 7, 6, <b>8</b>, <b>9</b>]</td>
                <td>Swap 4 & 1 → Swap 8 & 5 → Swap 8 & 2 → Swap 8 & 7 → Swap 8 & 6</td>
              </tr>
              <tr>
                <td>3rd iteration</td>
                <td>[1, 3, 4, 2, 5, 6, <b>7</b>, <b>8</b>, <b>9</b>]</td>
                <td>Swap 5 & 2</td>
              </tr>
              <tr>
                <td>4th iteration</td>
                <td>[1, 3, 2, 4, 5, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b>]</td>
                <td>Swap 4 & 2</td>
              </tr>
              <tr>
                <td>5th iteration</td>
                <td>[1, 2, 3, 4, <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b>]</td>
                <td>Swap 3 & 2</td>
              </tr>
              <tr>
                <td>6th iteration</td>
                <td>[1, 2, 3, <b>4</b>, <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b>, <b>9</b>]</td>
                <td>No swaps → album now sorted</td>
              </tr>
            </tbody>
          </table>
        </div>
  
        <p class="text-indent mt-4">
          The example image above goes through the first two iterations of bubble sort, but this algorithm will have many iterations due to its slow approach which is making many comparisons. 
          In total this array would have 8 iterations to go through before having a sorted array, but breaking down this example, we are given an unsorted array, A, with 9 elements. An 
          element that is high lighted in yellow indicated the current element we are looking to compare. On each pass of the array, we are comparing elements A[i] to its neighbor A[i+1], 
          and comparisons are made til the last element. Notice how after the first iteration, the largest element in our array, 9, has now been sorted into its correct sport, i.e., the end 
          of the array. After each iteration, the largest element gets sorted in its correct spot, so in the second iteration, the second largest element, 8, will be in its correct spot. Also, 
          note that on iteration 2, we are making one less comparisons than in the first iteration. This is because it is known that the last element is sorted, so we don't look at it to save us from 
          performing unnecessary comparisons.
        </p>
      </div>
    </div>
  
    <!--AC01312025 -- Each algorithm should talk about time complexity-->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">Runtime:</h2>
        <table class="table text-center w-50 mx-auto" style="border: 2px solid black; border-collapse: collapse;">
          <thead>
            <tr>
              <th class="fw-semibold" style="border: 2px solid black;">Case</th>
              <th class="fw-semibold" style="border: 2px solid black;">Time Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: 2px solid black;">Best</td>
              <td style="border: 2px solid black;">O(n)</td>
            </tr>
            <tr>
              <td style="border: 2px solid black;">Average</td>
              <td style="border: 2px solid black;">O(n²)</td>
            </tr>
            <tr>
              <td style="border: 2px solid black;">Worst</td>
              <td style="border: 2px solid black;">O(n²)</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Analysis:</h3>
        <p class="text-indent">
          When looking at the time complexity of algorithms, the focus is really on the average and worst case, as they are more likely to occur. Analyzing the runtimes of bubble sort, 
          the best case is unlikely as its only achievable on an already sorted array. The O(n) runtime would happen because if the array is already sorted then the algorithm just makes 
          one pass through, with no comparison which would just be O(n). The more likely scenario, is O(n²), and this will occur because of bubble sort needing to loop through value in 
          an array, and then also make comparisons on those values. Observing the pseudo code of bubble sort,
        </p>
  
        <div class="container text-center my-4">
          <img src="/static/learnApp/images/bubble_sort_pseudo.png" alt="Bubble Sort Example" class="img-fluid border-black" style="max-width: 300px; height: auto;">
          <p class="image-caption">Pseduocode for bubble sort</p>
        </div>
  
        <p class="text-indent">
          One for loop is required to pass through the array of n elements, and then another for loop is needed to make key comparisons with the A[i] and A[i+1]. This nested loop structure results in a time complexity of O(n * n) or O(n²) in the average and worst cases. 
          This makes the album inefficient for larger datasets as there are much faster sorting algorithms such as quick sort, but bubble sort works well on small sets as its easy to understand, 
          and is a good starting point when getting introduced to sorting algorithms. Bubble sort is also an in-place sorting algorithm that requires no extra space to sort, so it has a 
          space complexity of O(1).
        </p>
      </div>
    </div>
  </div>