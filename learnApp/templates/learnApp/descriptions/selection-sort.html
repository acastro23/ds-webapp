<div class="container py-4" style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 1.05rem;">

    <!-- Overview Section -->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">Introduction</h2>
        <p class="text-indent">
          Selection Sort is a sorting algorithm that repeatedly selects the minimum value from the unsorted portion of the array and swaps it with the first element.
          Then, it starts with the second element and goes through the rest of the array to find the new minimum and swaps it with the second element. 
          This process continues until the entire array is sorted.
        </p>
        <p class="text-indent">
          Selection Sort follows a brute-force approach. Brute-force algorithms check all possibilities to solve problems. 
          Selection Sort follows this idea by scanning the unsorted portion of the array to find the smallest element and placing it in its correct position, repeating this process until the array is fully sorted.
        </p>
      </div>
    </div>
  
    <!-- Example Section -->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Example</h3>
        <p class="text-center small fst-italic text-dark"><u>Given this array, sort it using Selection Sort</u></p>
        <div class="text-center mb-4">
          <img src="/static/learnApp/images/selectionsort1.png" alt="Selection Sort Example" class="img-fluid border-black" style="max-width: 300px; height: auto;">
        </div>
        <h4 class="text-center mt-4">Step-by-Step of Selection Sort</h4>
    <div class="table-responsive">
      <table class="table table-bordered text-center">
        <thead class="table-light">
          <tr>
            <th>Iteration</th>
            <th>Array</th>
            <th>Swaps Performed</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>1st iteration</td>
            <td>[<b>10</b>, 60, 30, 40, 50]</td>
            <td>Swapped 60 & 10</td>
          </tr>
          <tr>
            <td>2nd iteration</td>
            <td>[10, <b>30</b>, 60, 40, 50]</td>
            <td>Swapped 60 & 30</td>
          </tr>
          <tr>
            <td>3rd iteration</td>
            <td>[10, 30, <b>40</b>, 60, 50]</td>
            <td>Swapped 60 & 40</td>
          </tr>
          <tr>
            <td>4th iteration</td>
            <td>[10, 30, 40, <b>50</b>, 60]</td>
            <td>Swapped 60 & 50</td>
          </tr>
          <tr>
            <td>5th iteration</td>
            <td>[10, 30, 40, 50, <b>60</b>]</td>
            <td>No swap (last element)</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>
  
    <!-- Time Complexity Section -->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">Runtime:</h2>
        <table class="table text-center w-50 mx-auto" style="border: 2px solid black; border-collapse: collapse;">
          <thead>
            <tr>
              <th class="fw-semibold" style="border: 2px solid black;">Case</th>
              <th class="fw-semibold" style="border: 2px solid black;">Time Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: 2px solid black;">Best</td>
              <td style="border: 2px solid black;">O(n²)</td>
            </tr>
            <tr>
              <td style="border: 2px solid black;">Average</td>
              <td style="border: 2px solid black;">O(n²)</td>
            </tr>
            <tr>
              <td style="border: 2px solid black;">Worst</td>
              <td style="border: 2px solid black;">O(n²)</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  
    <!-- Analysis Section -->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Analysis:</h3>
        <p class="text-indent">
          The algorithm scans the entire unsorted portion of the array to find the smallest element.
          In the first pass, it checks <strong>n</strong> elements, in the second pass <strong>(n-1)</strong> elements, then <strong>(n-2)</strong>, and so on.
          Selection Sort is <strong>O(n²)</strong> due to the repeated full-array scans for the minimum element in each pass.
        </p>
        <p><b>Space Complexity:</b> Selection Sort has a space complexity of O(1) because it sorts the array in place without using any extra memory aside from a few variables for swapping.</p>
      </div>
    </div>
  
  </div>
  