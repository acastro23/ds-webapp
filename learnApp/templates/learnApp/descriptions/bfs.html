<div class="container py-4" style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 1.05rem;">
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Recap -- What are Graphs?</h3>
        <p class="text-indent">
          Graphs are abstract data structures that represent complex, non-linear relationships. They are important in 
          allowing us to depict how various elements are linked to one another. Visually, they are a collection of 
          points on a plane where those points are called <i>Vertices</i> or <i>nodes</i>. Some nodes are connected by 
          line segments called <i>edges</i> or <i>arcs</i>.
        </p>
        <div class="p-3 mb-4 rounded border border-dark bg-light text-dark" style="background-color: #f8f9fa;">
          <strong>Note:</strong> Graphs are either directed or undirected, check the figure below
        </div>
  
        <!-- AC03012025 -- POSSIBLE IMAGE OF DIRECTED/UNDIRECTED GRAPH VISUAL GOES HERE -->
  
        <p class="text-indent">
          Graphs, which are usually represented as G = (V, E), where |V| represents the number of vertices and |E|
          represents the number of edges, have two standard ways of being represented. Those two ways being an
          <i>adjacency list</i> and a <i>matrix</i>. For BFS, and other related graph algorithms, we'll assume that the 
          input graph is an adjacency list, but below are all the standard ways of representing a graph:
        </p>
  
        <!-- AC03012025 -- POSSIBLE IMAGE OF GRAPH REPRESENTATION VISUAL GOES HERE -->
      </div>
    </div>
  
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">BFS Introduction</h3>
        <p class="text-indent">
          Breadth-first Search, known as BFS, is one of the simplest algorithms for searching a graph and the 
          archetype for many important graph algorithms. The idea & concepts of other graph algorithms such as 
          Prim;s minimum spanning tree and Dijskstra single source shortest-path stem from breadth-first search.
        </p>
      </div>
    </div>
  
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Procedure</h3>
        <p class="text-indent">
          Given a graph G = (V,E) and some distinguished source vertex <i>s</i>. BFS works by exploring the edges of 
          G and <i>discover</i> every vertex that is reachable from the source vertex, <i>s</i>. When exploring, BFS 
          computes the distance from <i>s</i> to each reachable vertex, where the distance to some vertex <i>v</i> 
          would equal to the smallest numbers of edges needed to go from s to v. This produces a tree known as a 
          <i>'breadth-first tree</i> with root <i>s</i> that contains all reachable vertices.
        </p>
  
        <p class="text-indent">
          BFS keeps trach of its vertices through a first-in, first-out queue. The queue contains some vertices at 
          a distance k, which possibly are followed by some vertices at distance k + 1. When BFS starts, the source 
          vertex, which can be any node, gets enqueued and exploration begins on all vertices adjacent to the source.
          All explored vertices get enqueued, and once all nodes have been explored, the source vertex gets dequeued. 
          Its important to recognize, that we aren't visiting all vertices, just exploring them, only once all the
          adjacent vertices have been explored do we leave the source vertex and visit a new one which can also be in 
          any order. Visiting, or going deep, is not what BFS does, that method of exploration is the idea of DFS, which 
          is covered in another section. The following two images below will demonstrate a the procedure of BFS.
        </p>
  
        <div class="row align-items-center text-center my-3">
          <div class="col-md-5">
            <img src="/static/learnApp/images/bfs_example_pt1.png" class="img-fluid border-black">
            <p class="image-caption text-muted small">Figure 2.1</p>
          </div>
          <div class="col-md-2"></div>
          <div class="col-md-5">
            <img src="/static/learnApp/images/bfs_example_pt2.png" class="img-fluid border-black">
            <p class="image-caption text-muted small">Figure 2.2</p>
          </div>
        </div>
  
        <p class="text-indent">
          In Figure 2.1, a graph is given, and when performing BFS, the starting vertex, s is arbitrary. For this example, let s = 1. A yellow node indicates a vertex we are <i>visiting</i>,
          grey nodes indicate vertices that are being <i>explored</i>, and a red node indicates that the vertex has been <i>visited</i> already. So, starting from 1, the node is enqueued, and we 
          explore its adjacent vertices which are nodes 2, 4, and 5. When exploring, those vertices get enqueued, and once all the vertices have been explored, 1 gets dequeued and we proceed to 
          the next node, 2 and repeat the process as shown in (c). The order in which each vertex is visited is the order in which they get enqueued, so from node 1, we went to node 2 first,
          then node 4, and then node 5, but really we could've gone wherever, but for the purposes of this example, the vertices were visited in numerical order. Figure 2.2 finishes the BFS 
          procedure, and the operation is done when the queue is empty, but notice that last figure, i. That is our breadth-first tree, and it's a useful that can show us the shortest path 
          between two nodes, and by path, that means reaching a vertex v from s with the smallest number of edges.
        </p>
      </div>
    </div>
  
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">Runtime</h2>
        <table class="w-50 mx-auto" style="border-collapse: collapse; border: 2px solid black;">
          <thead>
            <tr>
              <th style="border: 2px solid black; padding: 8px; text-align: center;" class="fw-semibold">Case</th>
              <th style="border: 2px solid black; padding: 8px; text-align: center;" class="fw-semibold">Time Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">Best</td>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">O(V + E)</td>
            </tr>
            <tr>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">Average</td>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">O(V + E)</td>
            </tr>
            <tr>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">Worst</td>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">O(V + E)</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Runtime Analysis</h3>
        <p class="text-indent">
          As mentioned, BFS uses a queue to keep track of its vertices. The operation of enqueueing and dequeueing 
          takes O(1) time. Therefore, the total time for queue operations sums up to O(V) since the procedure scans 
          the adjacency list of each vertex only when the vertex is dequeued. This means BFS will scan each adjacency 
          list at most once. Since we also examine the edges incident on a vertex only when we visit from it, each 
          eadge is examined at most twice, so the sum of lengths of all |V| adjacency list is O(E). The runtime sums 
          up to be O(V + E) for best, average and worst case.
        </p>
        <p class="text-indent">
          The space complexity for BFS is O(V) where V is the number of vertices in the graph. This stems from the 
          auxilary data structures that BFS often uses in code implementation. For one, BFS uses a queue data structure 
          to keep track of the vertices to visit. At most, the queue will contain all vertices that are reachable from 
          source vertex, so the max number of vertices in the queue is bounded by the number of vertices in the graph. 
          In addition, a lot implementations of BFS use some kind of 'visited' array to keep track of visited vertices 
          to avoid revisiting them. This array also has a size equal to the number of vertices in the graph.
        </p>
        <div class="p-3 mt-4 rounded border border-dark bg-light text-dark" style="background-color: #f8f9fa;">
          <strong>Note:</strong> Some implementation of BFS may use other data structures or variables, but the space 
          required is often minimal compared to the queue and 'visited' array, so those implementations would not 
          change its overall space complexity of O(V).
        </div>
      </div>
    </div>
  </div>
  