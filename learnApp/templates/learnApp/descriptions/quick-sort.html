<div class="container py-4" style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 1.05rem;">
    <!---------------------------------------------------------Introduction Start-------------------------------------------------------------------------------------------------------->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">Introduction</h2>
        <p class="text-indent">
          Quicksort is a highly efficient and widely used sorting algorithm that follows the divide and conquer approach. 
          It uses Hoare's Partitioning which works by selecting a pivot element from the array and partitioning the other elements into two groups: those <b>less than the pivot</b> and those <b>greater than the pivot</b>. 
          These subarrays are then recursively sorted, and the final sorted array is obtained by combining the sorted subarrays with the pivot.
        </p>
        <p class="text-indent">
          Quicksort's performance depends on the choice of the pivot, as a well-chosen pivot leads to balanced partitions. 
          Quicksort is one of the fastest sorting algorithms.
        </p>
      </div>
    </div>
    
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">What Makes a Good Pivot?</h2>
        <p class="text-indent">
          A good pivot results in balanced partitions—where both halves of the array have approximately equal elements. 
          The median of the array is ideal, but calculating the exact median takes extra time.
        </p>
      </div>
    </div>
    
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">In-Place Sorting Algorithm</h2>
        <p class="text-indent">
          <b>Quick Sort</b> is an in-place sorting algorithm, meaning it does not require extra memory proportional to the input size.
          It modifies the array directly during partitioning.
        </p>
        <p class="text-indent">
          <b>Merge Sort</b> is NOT in-place. Merge Sort requires additional memory to store temporary subarrays during merging.
        </p>
      </div>
    </div>
    
    <!--------------------------------Example------------------------------>
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Example</h3>
        <p class="text-center small fst-italic text-dark">Let <code>i = left element, j = right element, and p = pivot</code></p>
        <div class="text-center mb-4">
          <img src="/static/learnApp/images/quicksort.png" alt="Quick Sort Example" class="img-fluid border-black" style="max-width: 300px; height: auto;">
        </div><br>
        <h2 class="card-title text-center">Pivoting the Array</h2><br>
        <div class="container">
          <div class="row text-center">
            <div class="col-md-4">
              <h5>Step 1: Select Pivot</h5>
              <p>The pivot is chosen, typically the first element (5 in this case). The array is partitioned such that all elements less than the pivot are on the left, and all elements greater are on the right.</p>
            </div>
            <div class="col-md-4">
              <h5>Step 2: Partitioning</h5>
              <p>In this step, i will increment until i>=p.<br>
                j will decrement until j<=p.<br>
                Then, swap the values at index i and j.<br>
                </p>
            </div>
            <div class="col-md-4">
              <h5>Step 3: Final Swap</h5>
              <p>When 'i' and 'j' pointers cross, the pivot element is swapped with the element at the 'j' pointer. This places the pivot in its correct position in the array.</p>
            </div>
          </div>
        </div><br>
        <h2 class="card-title text-center">How to Solve</h2><br>
        <div class="container">
            <ul class="ms-4">
                <li><b><code>p</code></b> is set to the first element (5), <b><code>i</code></b> is the second element (3), and <b><code>j</code></b> is the last element (7)</li>
                <li>i moves forward until it reaches 9, and j moves backwards until it reaches 4</li>
                <li>i and j swap places (9 and 4)</li>
                <li>i moves forward until it reaches 8, and j moves backwards until it reaches 2</li>
                <li>i and j swap places (8 and 2)</li>
                <li>i moves forward until it reaches 8, and j moves backward until it reaches 2</li>
                <li>Now, j is less than i, so j swaps places with p (2 and 5)</li>
                <li>Finally, 5 is in its correct position in the array. However, the elements to the left of 5 and right of 5 still need sorting.</li>
            </ul>
        </div>
    </div>
</div>

    <div class="card mb-4 shadow-sm">
        <div class="card-body">
          <h3 class="card-title text-center">Left Subarray</h3>
          <p class="text-center small fst-italic text-dark">Sort the left subarray</p>
          <div class="text-center mb-4">
            <img src="/static/learnApp/images/quicksort1.png" alt="Quick Sort Example" class="img-fluid border-black" style="max-width: 300px; height: auto;">
          </div><br>
          <div class="container">
            <p>We recursively apply the partitioning and pivoting steps to the subarray to the left of the pivot, until all elements are sorted.</p>
        </div>
    </div>
</div>

<div class="card mb-4 shadow-sm">
    <div class="card-body">
      <h3 class="card-title text-center">Right Subarray</h3>
      <p class="text-center small fst-italic text-dark">Sort the right subarray</p>
      <div class="text-center mb-4">
        <img src="/static/learnApp/images/quicksort2.png" alt="Quick Sort Example" class="img-fluid border-black" style="max-width: 300px; height: auto;">
      </div><br>
      <div class="container">
        <p>The same process is applied recursively to the subarray to the right of the pivot until that portion of the array is sorted.</p>
    </div><br>
    <h3 class="card-title text-center">Final sorted array: 1 2 3 4 5 7 8 9</h3>
    </div>
</div>
    
    
    <!--------------------------------Time Complexity Start----------------------------------------------------------->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h2 class="card-title text-center">Runtime</h2>
        <table class="w-50 mx-auto" style="border-collapse: collapse; border: 2px solid black;">
          <thead>
            <tr>
              <th style="border: 2px solid black; padding: 8px; text-align: center;" class="fw-semibold">Case</th>
              <th style="border: 2px solid black; padding: 8px; text-align: center;" class="fw-semibold">Time Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">Best</td>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">O(nlogn)</td>
            </tr>
            <tr>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">Average</td>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">O(nlogn)</td>
            </tr>
            <tr>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">Worst</td>
              <td style="border: 2px solid black; padding: 8px; text-align: center;">O(n²)</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <!--------------------------------Time Complexity End------------------------------------------------------------>
    
    <!-- Analysis Section -->
    <div class="card mb-4 shadow-sm">
      <div class="card-body">
        <h3 class="card-title text-center">Analysis:</h3>
        <p class="text-indent">
            The best and average cases occur when the pivot is chosen such that it splits the array into two roughly equal halves at each step.
            In each step, the array partitions around a pivot which results in <b>two subarrays of size n/2</b>. 
            Each partitioning operation takes <b>O(n)</b> time because each element is compared to the pivot once.
        </p>
        <p class="text-indent">
            Since the array is divided in half each time, there are <b>log n</b> levels of recursion.
        </p>
        <p class="text-indent">
            The worst case occurs when the pivot is poorly chosen (the smallest or largest element in a sorted array).
            Instead of splitting the array into two roughly equal parts, one side gets n-1 values (almost everything), and the other side gets 0 values (nothing).
            Since you're only removing one value each time, you still have to go through almost the entire array to find the correct place for the pivot. 
            So it takes <b>O(n²)</b> time because you're doing n steps, and each step takes about n comparisons.
        </p>
        <p><b>Space Complexity:</b> Quicksort is an in-place sorting algorithm, so its space complexity is O(log n) due to the recursive calls on the subarrays.</p>
      </div>
    </div>
